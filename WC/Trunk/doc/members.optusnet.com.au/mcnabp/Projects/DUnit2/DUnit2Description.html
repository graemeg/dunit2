<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!--link rel="stylesheet" href="style.css"-->
<meta content="text/html; charset=UTF-8" http-equiv="content-type">
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<meta content="Delphi DUnit2 project to improve usability of DUnit" name="description">
<title>DUnit2 Description</title>
</head>
<body>
<div>
<h1>Advanced high integrity DUnit2 description.</h1>
</div>

<a name="Top"></a><br>

<ul>
<li><A href="#Introduction"><font size="5">Introduction</font></A>

<li><A href="#SetUp_and_Teardown"><font size="5">SetUp and Teardown</font></A>

<li><A href="#Constructors_and_Destructors"><font size="5">Constructors and Destructors</font></A>

<li><A href="#DUnit2_Constructors_and_Destructors"><font size="5">DUnit2 Constructors and Destructors</font></A>

<li><A href="#Test_Decorators"><font size="5">Test Decorators</font></A>

<li><A href="#SetUpOnce_and_TeardownOnce"><font size="5">SetUpOnce and TeardownOnce</font></A>

<li><A href="#Overrides"><font size="5">Overrides</font></A>

<li><A href="#Warnings"><font size="5">Warnings</font></A>

<li><A href="#Early_Exit_Check"><font size="5">Summary Level Checks</font></A>

<li><A href="#Error_Reporting"><font size="5">Error Reporting</font></A>

<li><A href="#ShutDown_Leak_Reporting"><font size="5">Optional Leak Report on Shutdown</font></A>

<li><A href="#DLL_Test_Suites"><font size="5">DLL Test Suites</font></A>

<li><A href="#TestFrameworkProxy"><font size="5">TestFrameworkProxy</font></A>

<li><A href="#GUITestRunner_and_TextTestRunner"><font size="5">GUITestRunner and TextTestRunner</font></A>

<li><A href="#Speed_of_execution"><font size="5">Speed of execution</font></A>

<li><A href="#Compatibility"><font size="5">Compatibility</font></A>

<li><A href="#Adapting%20Legacy%20code"><font size="5">Adapting Legacy code</font></A>

<li><A href="#Embedded_unit_tests"><font size="5">Creating TTestCase instances within test methods</font></A>

<li><A href="#Notable_design_changes"><font size="5">Notable design changes</font></A>

<li><A href="#Project_Registration"><font size="5">Project Registration</font></A>

<li><A href="#DUnit_Self_Testing"><font size="5">DUnit Self Testing</font></A>

<li><A href="#DUnit2_Unit_Test_Suite"><font size="5">DUnit2's Unit Test Suite</font></A>

<li><A href="#Excluding%20Tests"><font size="5">Excluding Tests</font></A>

<li><A href="#XML_Report_Generator"><font size="5">XML_Report_Generator</font></A>

<li><A href="#Closing_summary"><font size="5">Closing summary</font></A></li>
</ul>

<a name="Introduction"></a><font size="5">Introduction</font> <br>
<div style="MARGIN-LEFT: 40px"><font size="+1">For brevity the new code will be called DUnit2.<br>
<br>
 In both DUnit and DUnit2, unit tests comprise classes derived from TTestCase, each containing 1 or more published test procedures as shown in the example below. TTestCase is now an interfaced object.<br>
<br>
 <em><font face="Lucida Console">type<br>

TTestMyComms = class(TTestCase)<br>
published<br>
&nbsp; procedure VerifyThatThereIsAnUnAssignedCommPort;<br>
&nbsp; procedure VerifyThatTheCommPortOpens;<br>
&nbsp; procedure VerifyThatTheCommPortCloses;<br>
end;<br>
</font></em><br>
 Through the magic of RTTI or .NET Reflection DUnit is able to execute the published test procedures in an orderly fashion. Code written into test methods performs tests on user's code and calls one or more Check() procedures to signal pass or fail to the test framework.</font></div>

<font size="+1"><a name="SetUp_and_Teardown"></a><font size="5"><br>
SetUp and Teardown</font></font> 

<div style="MARGIN-LEFT: 40px"><font size="+1">Both versions of DUnit implement SetUp and Teardown procedures. These execute at run-time before and after every test method respectively, providing an excellent means to pre-initialize testcase specific data, objects, connections etc and clean up the mess after each method. SetUp and Teardown execute regardless of exceptions within any test method.<br>
<br>
Expanding the TTestCase class to include SetUp and Teardown procedures is simple as shown below.<br>
<br>
<em><font face="Lucida Console"> type<br>
 TTestMyComms = class(TTestCase)<br>
 private<br>

 // your field variables here<br>
protected<br>
&nbsp; procedure SetUp; override;<br>
&nbsp; procedure Teardown; override; // Close the Comm port here<br>
 published<br>
&nbsp; procedure VerifyThatThereIsAnUnAssignedCommPort;<br>

&nbsp; procedure VerifyThatTheCommPortOpens;<br>
&nbsp; procedure VerifyThatTheCommPortCloses;<br>
 end;<br>
</font></em><br>
"SetUp" and "Teardown" optional procedures provide a convenient means to initialize variables, grab and release resources etc. However when multiple test methods are defined and the operation involves slow processes, like dialing modems, execution can slow unacceptably. Test times can be reduced significantly if the slow process is executed once and pre-established values maintained for the entire test duration. Test writers sometimes attempt to overcome the slowdown by putting the initializing code into the class constructor. In DUnit up to V9.4 this approach is flawed for the reasons shown below.</font></div>

<font size="+1"><br>
<font size="5">Constructors and Destructors</font></font> 

<div style="MARGIN-LEFT: 40px"><font size="+1">In DUnit up to V9.4 each test procedure is implemented by creating individual instances of the defining TTestCase. As a consequence, the constructor runs for every defined test method. When the test suite is registered during initialization this activity occurs before the GUI opens. If the class utilizes a unique resource, global variable or grabs substantial amounts of memory then tests often fail inexplicably.<br>

<br>
The classic problem of placing code in the constructor might look like the following.<br>
<br>
<em><font face="Lucida Console">type<br>
TTestMyComms = class(TTestCase)<br>
 private<br>
 protected<br>
&nbsp; procedure SetUp; override;<br>

&nbsp; procedure Teardown; override;<br>
published<br>
&nbsp; procedure VerifyThatThereIsAnUnAssignedCommPort;<br>
&nbsp; procedure VerifyThatTheCommPortOpens;<br>
&nbsp; procedure VerifyThatTheCommPortCloses;<br>
<br>
&lt;&lt;&lt;&lt;&lt; Don't expect this to work properly in existing DUnit code &gt;&gt;&gt;&gt;&gt;<br>

public<br>
&nbsp; constructor Create(const CommPortNo: integer);<br>
&nbsp; destructor Destroy; override;<br>
 end;<br>
</font></em><br>
All constructor action takes place before the GUI fires up, so exceptions can force the application to close prematurely and sometimes fatally leak resources.<br>
Similarly, unless all object references get set to nil in the TTestCase destructor exceptions will occur during program closure.<br>
There are still occasions when it would be really advantageous to be able to initialize say a database connection once and hold it for the entire duration of the test framework execution. There are "complex" ways to achieve the effect but the methodology is not standardized across unit testers.</font></div>

<font size="+1"><br>
<a name="DUnit2_Constructors_and_Destructors"></a><font size="5">DUnit2 Constructors and Destructors</font></font> 

<div style="MARGIN-LEFT: 40px"><font size="+1">DUnit2's design has been improved, so the TTestCase constructor and destructor only runs once for each registration of the class. Consequently, in DUnit2 allocating resources in a once off operation becomes standardized, more visible and safer to implement. Care is still required however because creation and destruction still occurs outside the GUI existence.</font></div>

<font size="+1"><br>
<font size="5"><A 
name=SetUpOnce_and_TeardownOnce></A><FONT size=5>SetUpOnce and 
TeardownOnce</FONT><FONT size=3> <BR></FONT>
<DIV style="MARGIN-LEFT: 40px"><FONT size=+1>DUnit2 introduces two new protected 
procedures "SetUpOnce" and "TeardownOnce". These significantly simplify the 
process of writing efficient unit tests and overcome the need to associate 
decorators and decorated tests. An added bonus is the absence of additional text 
and nodes in the GUI display. DUnit2 handles and reports exceptions in these 
procedures appropriately. Field variables are common to all procedures in the 
class, reducing code complexity and maintenance.<BR><BR><FONT 
face="Lucida Console"><EM>type<BR>TTestMyComms = 
class(TTestCase)<BR>private<BR>// Shared variables go 
here<BR>protected<BR>&nbsp; procedure SetUpOnce; override;<BR>&nbsp; procedure 
SetUp; override;<BR>&nbsp; procedure Teardown; override;<BR>&nbsp; procedure 
TeardownOnce; override;<BR>published<BR>&nbsp; procedure 
VerifyThatThereIsAnUnAssignedCommPort;<BR>&nbsp; procedure 
VerifyThatTheCommPortOpens;<BR>&nbsp; procedure 
VerifyThatTheCommPortCloses;<BR>end;</EM></FONT></FONT></DIV><BR>Test Decorators</font></font> 


<div style="MARGIN-LEFT: 40px"><font size="+1"> Pattern aware DUnit author(s) provided a less convenient solution in V9.4 by introducing test "Decorators".<br>
<br>
To utilize a test decorator requires the coder to write a derivative class of TTestDecorator which also gets registered at initialization time. It contains just a SetUp and Teardown procedure. The following is an example.<br>
<br>
<em><font face="Lucida Console">type<br>
 TMyTestDecorator = class(TTestDecorator)<br>
 private<br>
 protected<br>

&nbsp; procedure SetUp; override;<br>
&nbsp; procedure Teardown; override;<br>
end;<br>
</font></em><br>
In the initialization section I think the registration is supposed to look something like the following.<br>
<br>
<em><font face="Lucida Console">initialization<br>
&nbsp; RegisterTest(TMyTestDecorator.Suite('Optional Name', TMyDecoratedTests.Suite));<br>

end.<br>
</font></em><br>
When the test suite is executed TMyTestDecorator's SetUp procedure executes once before any code in TMyDecoratedTests.<br>
Similarly TMyTestDecorator's Teardown procedure executes after the last Teardown in TMyDecoratoratedTests<br>
<br>
The simplicity of use eludes many, perhaps because there were few clear examples in the earlier DUnit documentation. The test decorator class solves the problem of having to set up and tear down code whenever the process only needs to be done once for a particular test case instance.<br>
<br>
For test writers the main problem is that field variables in the decorator are not easily shared with the decorated tests class. When multiple decorators are required there is no natural association to help keep track of which decorator class goes with which test case class.<br>
<br>
 Implementation of tests decorators in DUnit2 is straight forward. Decorator classes can continue to inherit from TTestSetup to gain access to GetName read or change the new DisplayedName property. Both classes register in the same manner as V9.4 DUnit2 test decorators can be nested to any depth but the issue of sharing variables still exist.<br>

Decorators can now register multiple test cases simultaneously thus:-<br>
<em><font face="Lucida Console"><br>
initialization<br>
&nbsp; RegisterTest(TMyTestDecorator.Suite('SuiteName' , TMyDecoratedTests.Suite,<br>
 TMoreDecoratedTests.Suite]));<br>
end.</font></em></font><br>
<br>
<font size="4">This improves the versatility because each contained TTestCase can use their own SetUp and TearDown procedures as required. In addition decorators can be nested in varoius ways:-<br>
<br>

 <span style="FONT-STYLE: italic; FONT-FAMILY: Lucida Console">RegisterTest(TTestTheDecorator.Suite('XXX', TestAnotherDecorator.Suite('YYY',</span>&nbsp; <span style="FONT-STYLE: italic; FONT-FAMILY: Lucida Console"> TTestTheDecorator.Suite('ZZZ',</span> <span style="FONT-STYLE: italic; FONT-FAMILY: Lucida Console">TTrialDecoratedTest.Suite))));</span><br>
</font><font size="4"> <span style="FONT-STYLE: italic; FONT-FAMILY: Lucida Console">&nbsp; RegisterTest(TTestTheDecorator.Suite('XXX',<br>
[TTrialDecoratedTest.Suite,// This is just an ordinary test<br>
 TTestAnotherDecorator.Suite('YYY',<br>

[TTrialDecoratedTest.Suite,</span></font> <font size="4"> <span style="FONT-STYLE: italic; FONT-FAMILY: Lucida Console"><br>
</span></font> <font size="4"> <span style="FONT-STYLE: italic; FONT-FAMILY: Lucida Console">TTestTheDecorator.Suite('ZZZ',<br>
</span></font> <span style="FONT-STYLE: italic; FONT-FAMILY: Lucida Console"><font size="4">TTrialDecoratedTest.Suite)])]));<br>
<br>
</font></span></div>

<a name="Data_sharing"></a> <font size="+1"><font size="5">Data sharing between decorators and test cases</font></font> <br>

<div style="MARGIN-LEFT: 40px"><font size="+1">DUnit V9.4 and prior needed to declare data for initialization by test decorators in common view of the decorator and decorated class definitions, usually as one or more global variables in a shared unit.<br>
DUnit2 has a new approach which keeps the data lifetime within the project's execution path.</font><br>
<font size="+1">To share data, even among disparate unit tests and interface deriving from ITestSetupData is defined and need only contain setters, getters and temporary storage. This is illustrated in sample code below provides a means to share a string reference.</font></div>

<font size="+1"><br>
 <span style="FONT-STYLE: italic; FONT-FAMILY: Lucida Console"><br>
ICheckTestSetUpData = interface(ITestSetUpData)<br>
['{8C61F458-86B5-4CD0-BF26-5366D28980CB}']</span><br>
<br>
 <span style="FONT-STYLE: italic; FONT-FAMILY: Lucida Console">&nbsp;&nbsp;function get_SetupData: string;</span><br>

 <span style="FONT-STYLE: italic; FONT-FAMILY: Lucida Console">&nbsp; procedure set_SetupData(const Value: string);<br>
</span> <span style="FONT-STYLE: italic; FONT-FAMILY: Lucida Console">&nbsp; property SetupData: string read get_SetupData write set_SetupData;<br>
</span> <span style="FONT-STYLE: italic; FONT-FAMILY: Lucida Console"> end;</span><br>
<br>
Now for the concrete class implementing the above interface.<br>
<br>
 <span style="FONT-STYLE: italic; FONT-FAMILY: Lucida Console"> TSetupData = class(TInterfacedObject, ICheckTestSetupData)&lt; BR &gt;</span> <span style="FONT-STYLE: italic; FONT-FAMILY: Lucida Console"> private</span><br>

 <span style="FONT-STYLE: italic; FONT-FAMILY: Lucida Console">&nbsp; FSetupData: string;<br>
&nbsp; function get_SetupData: string;</span><br>
 <span style="FONT-STYLE: italic; FONT-FAMILY: Lucida Console">&nbsp; procedure set_SetupData(const Value: string);<br>
published<br>
&nbsp; property SetUpData: string read get_SetUpData write set_SetUpData;<br>
end;<br>

</span></font> <br>

<div style="MARGIN-LEFT: 40px"><font size="+1"> At an appropriate point in the test suite execution an instance of the above class would be created, populated and it's reference stored in the execution control object's "TestSetUpData" variable. Before each test case executes the execution control object stores a reference to the above interfaced object in the test case's own TestSetUpData property. This gives test methods access to information prepared elsewhere. Data updated by test methods can also be passed back up the execution chain.</font><br>
<font size="+1">Finally the reference is automatically set to nil as each project terminates, so there should be no data leakage outside projects.</font></div>

<br>
<font size="+1"> <a name="SetUpOnce_and_TeardownOnce"></a></font>

<font size="+1">
<a name="Overrides"><font size="5">Overrides</font></a></font> <br>

 
<div style="MARGIN-LEFT: 40px"><font size="+1">DUnit V9.3 introduced the concept of "Post Execution Failures".<br>
There are two possible causes.</font> 

<ol>
<li><font size="+1">If test methods do not execute at least one call to Check() then the test may not indicate a test actually failed. A GUI global menu option "Fail TestCase if no checks executed" can be enabled so test methods which have not called Check() will fail.</font>

<li><font size="+1">Memory leak detection has a corresponding menu option and the amount of memory leaked gets shown in the resulting test failure report.</font></li>
</ol>

<font size="+1"> These soft failures increase the usefulness of tests and raise the level of test integrity. Some tests however may generate memory leaks by virtue of calling leaky code outside the coder's control. Sometimes such soft test failures might not be considered failures of the tested code. Memory leaks of known size can also be programmed to pass while allowing leaks of any other size to raise a failure.<br>
<br>

Similarly, some tests might not be programmed to call Check() because the tested code only needs to execute without raising an exception to be considered a pass. Boolean properties can be set during the test method execution to suppress post test failures, overriding the GUI's global command.<br>
"Overrides" was the count of tests set to suppress display of post execution failures.<br>
<br>
Note that potential post execution failures are not detectable or even show in V9.4 if they aren't armed to fail. Consequently testers may not be alerted to latent code problems.</font></div>

<font size="+1"><br>
<br>
<a name="Warnings"></a><font size="5">Warnings<br>
</font></font> 

<div style="MARGIN-LEFT: 40px"><font size="+1">DUnit2 advances test integrity by automatically detecting potential failures. DUnit2 replaces V9.4s Overrides display with "Warnings". This now presents the sum of potential post execution failures and overrides.<br>
The value has no meaning until the tests are executed.<br>

<br>
The location of warnings can now be displayed. See image below.<br>
<br>
<IMG style="WIDTH: 758px; HEIGHT: 547px" alt="Image shows effect of selecting Warn if fail test overridden" src="ShowWarnings.png"><br>
<br>
<br>
<font size="5">Showing tests which must never leak -or- must always call Check().<br>
</font>Some tests, usually those testing the interaction of classes or those relying on externally prepared test data can become complex. Tests that contain either if, case or {$ifdef condition} statements that may have data dependant execution paths which accidentally bypass all calls to Check().<br>
Similarly an unexpected memory leak in some tested code might be deemed critical and need to fail even if memory leak detection is turned off globally.<br>
<br>
The test writer can place statements in either SetUp or the test method:-<br>
<em><font face="Lucida Console">FailOnNoChecksExecuted :=  True;</font></em><br>

-or-<br>
<em><font face="Lucida Console">FailsOnMemoryLeak :=  True;</font></em><br>
<br>
To discover which tests contain these statements the user runs the tests with just the yellow button selected.<br>
Yellow - indicates which tests contain statements overriding the GUI, that have not failed.<br>
<br>
As mentioned above, in both V9.4 and DUnit2 the tester can choose to override the GUI global commands so specific test methods don't fail on soft failures. DUnit2 adds yellow and orange node colours to identify tests where run-time properties have overridden the GUI.<br>
Yellow - indicates which tests contain statements overriding the GUI, that have not failed.<br>
Orange - indicates which overridden tests would have failed.<br>
Neither show in the TestTree display if run-time properties have not been used.<br>

"Warnings" will however still have a count of the potential failures.<br>
<br>
<br>
<IMG style="WIDTH: 532px; HEIGHT: 523px" alt="Images shows warning locations" src="ShowNewButtons.png"><br>
</font></div>

<br>
<font size="+1"><br>
<br>
<font size="5">Summary Level Checks (early exit on pass)</font></font> 

<div style="MARGIN-LEFT: 40px"><font size="+1">Within test methods it is not uncommon to have a sequence of specific checks culminating in a definitive pass/fail check.<br>
An example could be a series of tests which validate individual aspects of a regular expression evaluator followed by a demonstration of all aspects combined.<br>
There are times where test suite execution times would benefit from executing the summary level test first and if it passes then skip the detailed level checks.<br>

Conversely, if the summary level test failed then all the summary level checks should run. If they all pass only the initial failure would be reported.<br>
DUnit2 now provides a means to execute a summary level check and if it passed the remaining checks are skipped.<br>
A single boolean check "EarlyExitCheck(boolean check result, 'Error message'); is now available for use.<br>
Tests following a "EarlyExitCheck() statement execute when the summary level check fails.<br>
<br>
Selecting "Inhibit Summary Level Checks" reverses the behavior of the EarlyExitCheck so the following checks run on pass.<br>
Summary level checks are only available within test methods and do not extend to the TTestCase level.<br>
<br>
</font></div>

<font size="+1"><a name="Error_Reporting"></a><font size="5">Error Reporting</font></font> 


<div style="MARGIN-LEFT: 40px"><font size="+1">When an error or test failure occurs DUnit2 now reports the whole test path from the top level node down to the individual method name. See image above.<br>
In all DUnit versions (D5..D10) when USE_JEDI_JCL is defined in project - options - conditionals, if the linker includes the .map file the source code line number location is displayed. In DUnit2 if the map file was not linked a message to that effect appears next to the error address.<br>
<br>
Individual or selected parts of error messages can now be copied to the clipboard using new GUI menu options.<br>
<br>
<IMG style="WIDTH: 391px; HEIGHT: 64px" alt="Clipboard functions available when tests is selected in the ErrorMessage window." src="ClipboardErrorMessageFunctions.png"><br>
<br>
Additionally all the error messages pertaining to a Treeview node can be viewed in the ErrorMessage window. Clicking on the top level project node shows all of the error messages<br>
<br>
<IMG height=725 alt="Summary of all error messages pertaining to the clicked TreeView node" src="ErrorSummary.png" width=760></font></div>

<a name="ShutDown_Leak_Reporting"></a><font size="5"><br>
Optional Leak Report on Shutdown</font> 


<div style="MARGIN-LEFT: 40px"><font size="+1"> When compiled with FastMM4 DUnit provides an optional detailed leak report on shutdown. This has been configured to require Delphi to be running. See images below.<br>
<br>
</font></div>

<font size="+1"><font size="5"><IMG height=298 alt="Options menu entry for Optional leak report on shutdown" src="LeakReportOnShutdown.png" width=254></font></font><br>
<font size="+1"><font size="5"><br>
<small>FastMM4's Shutdown Leak Report</small><br>
<br>
<IMG style="WIDTH: 784px; HEIGHT: 184px" alt="Typical FastMM4 shutdown leak report" src="Shutdown_Decteded_Leak_Report.png"><br><br>
DLL Test Suites</font></font> 

<div style="MARGIN-LEFT: 40px"><font size="4">Test suites can now be compiled into a DLL and registered and executed in the same manner as conventional unit tests. There was a similar non obvious functionality in the previous DUnit. DLLs each register as separate Projects using their filename.<br>
The purpose is to allow groups of separately prepared unit tests to be gathered on one machine and executed under the same test scenario. So one DLL might be compiled with Optimisation ON and another with Align Records ON etc. DLLs compiled under D7 executed correctly when run under D10. (BDS2006)</font></div>

<br>
<font size="+1"><a name="TestFrameworkProxy"></a><font size="5">TestFrameworkProxy</font></font> 

<div style="MARGIN-LEFT: 40px"><font size="+1">DUnit2 has been developed from the lowest level back towards the GUI, with the eventual aim of rewriting the middle and upper layers to support multi-threaded testing. The GUI of course will always run in the VCL thread. To facilitate early testing and not break too much code, particularly other people's tests an intermediate object class has been introduced to marry the new and old as code.<br>
<br>
An object tree structure of ITestProxy is interposed between the GUI/Test test runners and the new DUnit core. Consequently the GUI never sees the real ITests or ProjectsManager. This extra layer undoubtedly slows execution, but not to any detrimental degree.</font></div>

<font size="+1"><br>
<br>
<a name="GUITestRunner_and_TextTestRunner"></a><font size="5">GUITestRunner and TextTestRunner</font></font> 

<div style="MARGIN-LEFT: 40px"><font size="+1"> GUITestRunner and TextTestRunner have been modified to use a new ITestProxy class and a modified version of TTestResult. TTestResult has been changed to an interfaced object and most executable code pruned out. The method of initiating test execution has changed slightly which necessitated changes to both test runners. Other slight changes stem from the way test results are propagated back to the GUI. TestListeners are still used as before.</font></div>

<font size="+1"><br>
<br>
<a name="Speed_of_execution"></a><font size="5">Speed of execution</font></font> 

<div style="MARGIN-LEFT: 40px"><font size="+1"> During the process of analyzing the original DUnit's inner workings to add leak detection one aspect of the execution flow became obvious. TTestResult was repeatedly visiting then being visited by the execution flow in a very hard to follow manner (well for me, not necessarily for the initial writers). One consequence was that memory leak detection code had to execute multiple times for each test method.<br>
<br>
Another point of code inefficiency involves reporting status back to the GUI after every test. The existing DUnit code unnecessarily refreshes the TestTree right back up to the highest node for every test regardless of whether there will be any status change. DUnit2 only ripples necessary changes back to the higher levels.<br>
<br>
Normal displayed unit testing times show very little difference between the new and old code. However there is a significant speed increase when conducting repeat tests. 10000 loops calling Check(True) from a RepeatTest decorator in older DUnit takes 145 secs compared with only 38 secs in new DUnit2. Efforts to improve code efficiency are paying dividends, albeit in an infrequently used aspect.<br>
One unexpected speed improvement occurs when executing TextTestRunner on a complex project's suite of tests (1200+) such as tiOPF2. The new tests begin execution approximately 4 seconds earlier.<br>
<br>

Prior to test suite execution DUnit2 builds a linear list of ITest references in each TestProject for rapid access at runtime. The list is is now scanned sequentially rather than code reccursing into a tree structure. Calls back to the TestTree to check each node for enabled status have been replaced but other Listeners are still polled.</font></div>

<font size="+1"><br>
 <a name="Compatibility"></a><font size="5">Compatibility</font></font> 

<div style="MARGIN-LEFT: 40px"><font size="+1">For simple projects the main .dpr just needs to name GUITestRunner or TextTestRunner as before. The project paths should be pointed to the new code src folder or DCU set. Similarly, most unit tests still only need to refer to TestFramework.<br>
<br>
 TTestResult class definition had been hidden from external access and a function GetTestResult now returns an interfaced object version instead. So, for those specialist test suite writers who directly access TestResult data need to call that function to get a reference. The variable is now an interface type which should to be set to nil instead of calling .Free. Nothing major.<br>
Similarly, TTestFailure has been upgraded to being an interface and no longer requires a call to .Free to clean up each instance.<br>
<br>
 Existing unit tests are still register as before. e.g. :-<br>

<br>
 <font size="+1"><em><font face="Lucida Console">Registertest(TMyTestCase.Suite);<br>
Registertests('MyNamedGroupOfTests', [TTestCaseABC.Suite, TTestCaseXYZ.Suite]);<br>
</font></em><br>
</font> Registering multiple test in the same named TestSuite will display the tests together in the TestTree view and their execution will be sequential.<br>
<br>
Legacy Unit Test Suites.<br>
Some "legacy" unit tests with complex test scenarios have not been converted to using interfaces yet and may so not compile because the required TTestCase methods are not public. As an aid, All Check() and Fail() methods have been made public. In addition TAbstractTest definition has been re-added to the code and represents an ITestProc. A parameterless RunTest method has been added.<br>
<br>
</font></div>

<a name="Embedded_unit_tests"></a><font size="5">Creating TTestCase instances within test methods.</font> 

<div style="MARGIN-LEFT: 40px"><font size="+1">Unit test writers who create instances of TTestCase on the fly (now an interfaced object) need to change variable definitions from TTestCase to ITestCase. Naturally one should not call .Free when their useful life has passed. Either set the reference to nil or let them die by Delphi magic.<br>
Perhaps more noticeable is that the constructor for TTestCase instances no longer needs a string parameter. In all the unit tests I have encountered these have all been empty i.e.<br>
<br>
<em><font face="Lucida Console">FMyTestCase :=   TMyTestCase.Create('');<br>
// &lt;&lt;&lt;becomes&gt;&gt;</font></em></font></div>

<div style="MARGIN-LEFT: 40px"><font size="+1"><em><font face="Lucida Console">FMyTestCase := TMyTestCase.Create;</font></em></font></div>

<div style="MARGIN-LEFT: 40px"><font size="+1"><br>
Note. DUnit2 now allows creating TTestCases with an empty string. TTestCase can be inherited from and additional characteristics added. New classes also need to override the appropriate constructor(s) to ensure proper registration. Adding once off setup operations in these constructors is now possible although it has disadvantages compared with using SetUpOnce.<br>
<br>
TTestCase instances created on-the-fly should be allocated to a local or field variable and should not be registered. Code can be executed by calling LMyTests.Run(AnIExecControl) where AnIExecControl is a local instance of an ITestExecControl. For the following code to compile an additional unit "TestFrameworkIfaces" may need to be added to your unit test's uses clause.<br>
<br>
<em><font face="Lucida Console">interface<br>
uses<br>
 TestFrameworkIfaces,<br>
 TestFramework;<br>

<br>
......<br>
<br>
implementation<br>
<br>
procedure TMyTestCaseRunner.VerifyMyEmbeddedTestCasePasses;<br>
 var LMyTestCase: ITestCase; // Might need to be TMyTestCase in .NET<br>
 LExecControl: ITestExecControl;<br>
 begin<br>&nbsp; LExecControl :=  
    TestExecControl;<br>

<br>
 // Get ref to new instance of a TTestExecControl<br>&nbsp; LMyTestCase :=  
   TMyTestCase.Create;&lt;<br>
&nbsp; Check(LMyTestCase.Run(LExecControl) = _Passed, 'Oh damn, it failed');<br>
<br>
 // No need to destroy the local vars, they are interfaces and Delphi does it for you<br>
<br>
 end;</font></em></font></div>

<br>
<a name="Adapting Legacy code"></a><font size="5">Providing partial V9.4 compatibility.</font> 

<div style="MARGIN-LEFT: 40px"><font size="+1">Some users add functionality to DUnit that was not anticipated during it's initial design.<br>
To aid this process the following changes have been incorporated.<br>
<br>
 Crafted unit tests can now be executed by calling RunTest instead of defining a test method.<br>
The first step is to define a new type inherited from ITestProc or for Legacy code TAbstractTest.<br>
In the class definition override RunTest and place the test code and Check() or Fail() therein.<br>
The constructor can accept a string which does not have to conform with Delphi method names.<br>

Note, there can only be one RunTest method defined per class.<br>
RunTest does not take TTestResult as a parameter and is not called from TTestResult.<br>
At run time create an inherited empty instance of TTestCase and add one or more of the above TTestProcs.<br>
Register the containing TTestCase in the normal fashion.</font></div>

<blockquote dir="ltr" style="MARGIN-RIGHT: 0px"><em><font face="Lucida Console"><font size="+1"><br>
type<br>
TMyRunTestExample = class(TTestProc) //-or- (TAbstractTest) if it's existing code<br>
public<br>
&nbsp; Procedure RunTest; override;<br>

end;<br>
<br>
TMyRunTestRunner = class(TTestCase)<br>
// Empty but can have SetUp, TearDown procedures if desired<br>
end;<br>
.....<br>
TMyRunTestExample.RunTest;<br>
begin<br>
// Do something useful<br>

&nbsp; Check(SomeBooleanResult, 'My error message');<br>
end;<br>
....<br>
var<br>
 LTest: ITestCase;<br>
initialization<br>&nbsp; LTest :=
   TMyRunTestRunner.Suite;<br>
&nbsp; LTest.AddTest(TMyRunTestExample.Create('A funny !! name');<br>

&nbsp; RegisterTest(LTest);<br>
</font></font></em></blockquote>

<br>
 <br>
<a name="Notable_design_changes"></a><font size="5">Notable design changes</font> 

<ul>
<li><font size="+1"> The TestResult object has been replaced at the low level by an interfaced object TTestExecControl which contains property getters and setters.</font>

<li><font size="+1">The interface definitions start at the basic ITest - and progresses through to ITestProject.</font>

<li><font size="+1">When TTestCase instances are registered only one instance is created and test methods each spawn an ITest instance.</font>

<li><font size="+1">ITestSuite represents a visibly named group of ITestCases, the same as in V9.4.</font>

<li><font size="+1">Above ITestSuite are ITestDecorator IRepeatTest and ITestProject.</font>

<li><font size="+1">ProjectsManager looks after the registration of all tests and is hidden from casual view.</font>

<li><font size="+1">Execution paths have been straightened out considerably.</font>

<li><font size="+1"> The requirement for TAbstractTest has been superseeded.</font>

<li><font size="+1">All test method names need to be legitimate Delphi procedure names. However during test registration their displayed name can be manipulated if necessary. An example of this occurs in the tiOPF2 test suite where test procedure names are prefixed with the database type under test.</font>

<li><font size="4">There are two additional Check() procedures for comparing Int64 values as well as the new EarlyExitCheck() capability.</font>

<li><font size="4">An XML Reporter has been added to provide a viewable report for web page deployment.</font>

<li><font size="4">Individual tests can be excluded from execution by the inclusion of identifying information in the DUnit.ini file.</font>

<li><font size="4">2 buttons have been added to the GUI to show Memory Leak and Checkless test option status.</font>

<li><font size="4">3 buttons have been added to the GUI to select post execution TestTree display functionality.</font></li>

</ul>

<font size="+1"><br>
 <a name="Project_Registration"></a><font size="5">Project Registration</font></font> 

<div style="MARGIN-LEFT: 40px"><font size="+1">Existing unit tests suites appear in the TestTree in exactly the same manner as V9.4. The root node is assigned the project executable name and tests follow in order of registration. Tests registered in named Test Suites however are grouped together, regardless of registration order as in V9.4.<br>
To segregate tests for execution in separate threads (future work) a new inherited type "ITestProject" has been introduced.<br>
<br>
When more than one project is registered test cases not specifically register to a named project are relegated to a project called "Default Project". The TestTree becomes:-<br>
<br>
ProjectName.exe - Default Project<br>
 some test cases<br>

 FirstNamed Project<br>
 some more test cases<br>
 SecondNamedNamed Project etc.<br>
 even more test cases<br>
<br>
A suite of tests can be compiled into a DLL and registered using unit "TestModules.pas" procedures.<br>
DLL based tests show in the TestTree as a project using the DLL name. At some time in the future someone more familiar with .NET might like to so the same for Assemblies. Registration is shown below.</font></div>

<div style="MARGIN-LEFT: 40px"><font size="+1">RegisterModuleTests('Full path and dll filename.ext');</font></div>

<div style="MARGIN-LEFT: 40px"><font size="+1"><br>
The syntax for registering tests in named a project is simple. In unit test unit's initialization section the registration code looks like the following.<br>
<br>
<em><font face="Lucida Console">ProjectRegisterTest('My First Ever Project', TMyTestCase.Suite);<br>
RegisterTest(TMyTestCase.Suite); // Automatically allocated to the "Default Project"<br>
ProjectRegisterTests('My Next Project', [TTestCaseABC.suite, TTestCaseXYZ.Suite]);<br>
ProjectRegisterTests('My Suite Project', 'A Test Suite Of Tests', [TTestCaseJKL.suite, TTestCaseMNO.Suite]);<br>
<br>

</font></em></font></div>

<div style="MARGIN-LEFT: 40px"><font size="+1">If multi-threading is added to DUnit2 the default project will run in the context of the VCL thread for maximum compatibility with existing code.<br>
<br>
A simple demo of multiple registered "Projects" is illustrated below.<br>
<br>
<IMG height=658 alt="Image shows multiple registered projects" src="MultipleProjects.png" width=477><br>
<br>
Note that "MiniTestLibW32.dtl" is a suite of tests compiled into a dll, registered and executed along with ordinary tests.<br>
<br>
<A href="#Top">Back to Top</A></font></div>

<font size="+1"><br>

<br>
 <a name="DUnit_Self_Testing"></a><font size="5">DUnit Self Testing</font></font> <br>
 

<div style="MARGIN-LEFT: 40px"><font size="+1"> Both V9.4 and DUnit2 use a global variable in memory to hold a reference to the registered TestCases instances. DUnit2 test suite verifies this variable get cleared on pseudo shutdown. Unfortunately this also deletes the running tests themselves so a parallel set of essential DUnit code is invoked in a separate Ref folder to execute the DUnit self tests. These duplicate units are easily kept in sync with the deployed DUnit code but have unit names starting with "Ref"<br>
<br>
Define 'SELFTEST' in the project conditionals automatically invokes the duplicate code. All DUnit self testing should be calling RefTestFrameworks.RegisterTest(); to put the tests into the TestTree view.<br>
<br>
In code tests i.e. those being executed with registered tests need to be prefixed as:-<br>
 TestFramework.RegisterTest(MyTestedTests.Suite); to avoid a compile time ambiguity error.<br>

<br>
TestFramework makes use of FastMM4 for detecting memory leaks and provide some speed improvement.<br>
<br>
FastMM4Options.inc can be modified if specific options are deemed necessary.<br>
The latest .zip of files uses FastMM4 rev 4.88 and the shipped FastMM4Options.inc<br>
 FASTMM should always be linked with the code, even on BDS2006.<br>
<br>
The JEDI_JCL code can optionally be linked and provides stack tracing and exception error reporting when the code is linked with it's .map file. D5 through to BDS2006/7 support the library. It was necessary to delete one reference in a uses clause for compilation under .NET.<br>
When JEDI_JCL is armed to perform stack tracing the generated strings acquire memory which the memory leak detection code flags as a soft failure. Provision has been made in code to allow StackTracing to be disarmed when memory leak detection is enabled.</font></div>

<font size="+1"><br>
<br>
 <a name="DUnit2_Unit_Test_Suite"></a><font size="5">DUnit2 Unit Test Suite</font></font> 

<div style="MARGIN-LEFT: 40px"><font size="+1">DUnit2 tests have been written continuously since coding began. Many test methods extensively validate the test itself before performing the final calls to Check(). This gives considerable confidence in the final result.<br>
Once the low level TestFramework and TestFrameworkProxy harness was validated a set of unit tests from an unrelated project were linked with DUnit2 and executed correctly on the first attempt.<br>
<br>
Exposure to tiOPF2 unit tests has been invaluable in teasing out compatibility issues and managed to expose an untested aspect recently. Naturally an additional unit test to capture the issue has been added to the test suite.<br>
<br>
Condensed view of unit tests executing 21st May 2007 showing the range of testing conducted.<br>
<br>
 <IMG style="WIDTH: 532px; HEIGHT: 779px" alt="Entire suite of tests executed as two projects" src="TwoProjects.png"><br>

<br>
<A href="#Top">Back to Top</A></font></div>

<font size="+1"><br>
<a name="Excluding Tests"></a></font><font size="5">Excluding Tests</font> 

<ul>
<li><font size="+1">Individual tests can now be excluded separately from Enabling and Disabling tests.</font>

<li><font size="+1">Excluded test state is persisted in DUnit.ini and is not cleared by globally enabling tests.</font>

<li><font size="+1">To exclude a test in the GUI version right click on the test and choose Exclude Test Execution.</font>

<li><font size="+1">To re-include tests right click on the test and choose Include Test Execution.</font>

<li><font size="+1">Excluded tests are shown with a red X in the GUI test treeview.</font>

<li><font size="+1">Excluded tests are stored in Sections in DUnit.ini and include the project name.</font>

<li><font size="+1">To exclude the same tests from execution in console mode duplicate the sections in the .ini file and change the project name accordingly.</font>

<li><font size="+1">In console mode (TextTestRunner) excluded tests are shown with an x in place of dots.</font>

<li><font size="+1">After tests suite execution the XML report file shows the number of Excluded tests.</font></li>

</ul>

<font size="+1"><IMG style="WIDTH: 478px; HEIGHT: 640px" alt="View of excluded tests in GUI version" src="ExcludedTests.png"><br>
<br>
<br>
<a name="XML_Report_Generator"></a></font><font size="5">XML Report Generator</font> 

<ul>
<li><font size="+1">An XML report generator has been added for D7..D10 but not .NET.</font>

<li><font size="+1">D7..D10 automatically link to the supplied xdom.pas.</font>

<li><font size="+1">To compile D5 or D6 xdom.pas would need to be copied from a higher Delphi version and several compiler specific $IFDEFs removed to include XMLListener.pas.</font>

<li><font size="+1">The report format follows the style used by the tiOPF2 project.</font>

<li><font size="+1">Reports are automatically created at the end of each suite execution.</font>

<li><font size="+1">the .XML file is saved in the same location as the test executable.</font>

<li><A href="DUnit2Test.xml"><font size="+1">DUnit2 XML test results report. Note tag difference to tiOPF2 shown below</font></a></li>
</ul>

<div style="MARGIN-LEFT: 2em"><font size="+1"><br>
An example file running tiOPF2 tests is shown below in two sections, beginning and ending.<br>
<br>

<IMG style="WIDTH: 1183px; HEIGHT: 387px" alt="Beginning of XML report" src="XMLStart.png"><br>
<br>
<IMG style="WIDTH: 876px; HEIGHT: 422px" alt="Final section of XML report" src="XMLEnd.png"><br>
<br>
<a name="Closing_summary"></a> <font size="5">Closing summary</font></font></div>

<ul>
<li><font size="+1"> DUnit2 appears very stable and largely compatible with existing standard test suites.</font>

<li><font size="+1">The addition of SetUpOnce and TearDownOnce adds significant versatility.</font>

<li><font size="+1">Testing integrity has been strengthened with potential soft failures detected automatically.</font>

<li><font size="+1">Named projects provide a pathway for future improvements to run multi threaded unit testing.</font>

<li><font size="+1">The test framework does not leak memory or resources.</font>

<li><font size="+1">Decorated tests can be nested.</font>

<li><font size="+1">Repeated tests execute significantly faster.</font>

<li><font size="+1">TTestCase Constructors and Destructors only run once.</font>

<li><font size="+1">New Int64 Check() procedures and EarlyExitCheck capability have been added.</font>

<li><font size="+1">An XML report generator has been added (.NET excluded).</font>

<li><font size="+1">Individual tests can be excluded from execution.</font>

<li><font size="4">The code is still undergoing refinement in particular to improve readability and maintainability.</font>

<li><font size="4"><A href="FeatureMatrix.html">Check methods feature matrix</a>.</font></li>
</ul>

<font size="+1"> <A href="#Top"> Back to Top</A><br>

<br>
<font size="3">Page last updated 29th Aug 2008</font><br>
<br>
 Copyright<br>
 DUnit Group 2006, 2008<br>
All rights reserved.<br>
<br>
<br>
<a href="http://validator.w3.org/check?uri=referer"><IMG height=31 alt="Valid HTML 4.0 Transitional" src="valid-html40.png" width=88></a></font> </FONT>
<IMG class=maincounter alt="Page Hit Counter" src="/cgi-bin/counter?width=6&amp;font=A&amp;name=mcnabp11">

</body>
</html>

